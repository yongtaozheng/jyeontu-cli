const htmlPdf = require('html-pdf-node');
const fs = require('fs-extra');
const path = require('path');
const inquirer = require("@jyeontu/j-inquirer");
const PDFLib = require('pdf-lib');

class MarkdownToPdfConverter {
    constructor(obj) {
        this.action = obj.action;
        this.mdFilePath = obj.mdFilePath;
        this.mdDir = obj.mdDir;
        this.pdfDir = obj.pdfFilePath;
    }

    async init() {
        console.log('üöÄ ÂàùÂßãÂåñMarkdownËΩ¨PDFËΩ¨Êç¢Âô®...');
        await fs.ensureDir(this.pdfDir);
        console.log('‚úÖ ËΩ¨Êç¢Âô®Â∑≤ÂàùÂßãÂåñ');
    }

    async convertMdToPdf(mdFilePath) {
        const fileName = path.basename(mdFilePath, '.md');
        const pdfFilePath = path.join(this.pdfDir, `${fileName}.pdf`);
        
        try {
            const content = await fs.readFile(mdFilePath, 'utf-8');
            
            if (content.length > 500000) {
                console.log(`üìÑ Êñá‰ª∂ËæÉÂ§ßÔºåÂ∞ÜÂàÜÊÆµÂ§ÑÁêÜ`);
                await this.convertLargeFile(content, fileName, pdfFilePath);
            } else {
                await this.convertSmallFile(content, fileName, pdfFilePath);
            }
            
            console.log(`‚úÖ ËΩ¨Êç¢ÂÆåÊàê: ${fileName}.pdf`);
            
        } catch (error) {
            console.error(`‚ùå ËΩ¨Êç¢Â§±Ë¥• ${fileName}:`, error.message);
        }
    }

    async convertSmallFile(content, fileName, pdfFilePath) {
        const htmlContent = this.generateHTML(content, fileName);
        const tempHtmlPath = path.join(__dirname, 'temp_md.html');
        await fs.writeFile(tempHtmlPath, htmlContent, 'utf-8');
        
        try {
            const options = {
                format: 'A4',
                margin: {
                    top: '2cm',
                    right: '2cm',
                    bottom: '2cm',
                    left: '2cm'
                },
                printBackground: true,
                displayHeaderFooter: true,
                headerTemplate: '<div style="font-size: 10px; text-align: center; width: 100%; color: #666;">' + fileName + '</div>',
                footerTemplate: '<div style="font-size: 10px; text-align: center; width: 100%; color: #666;">Á¨¨ <span class="pageNumber"></span> È°µÔºåÂÖ± <span class="totalPages"></span> È°µ</div>',
                timeout: 120000
            };
            
            const file = { url: `file://${tempHtmlPath}` };
            const buffer = await htmlPdf.generatePdf(file, options);
            await fs.writeFile(pdfFilePath, buffer);
            
        } finally {
            // await fs.remove(tempHtmlPath);
        }
    }

    generateHTML(content, title) {
        const htmlContent = this.markdownToHtml(content);

        return `
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${title}</title>
    <!-- MathJax ÈÖçÁΩÆ -->
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['\\\\(', '\\\\)']],
                displayMath: [['\\\\[', '\\\\]']],
                processEscapes: true,
                processEnvironments: true,
                packages: ['base', 'ams', 'noerrors', 'noundefined']
            },
            options: {
                ignoreHtmlClass: 'tex2jax_ignore',
                processHtmlClass: 'tex2jax_process',
                enableMenu: false,
                menuOptions: {
                    settings: {
                        texHints: true,
                        semantics: false,
                        zoom: 'NoZoom'
                    }
                }
            },
            startup: {
                pageReady: () => {
                    return MathJax.startup.defaultPageReady().then(() => {
                        console.log('MathJax is loaded');
                    });
                }
            },
            loader: {
                load: ['[tex]/ams', '[tex]/noerrors', '[tex]/noundefined']
            }
        };
    </script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        body {
            font-family: 'Microsoft YaHei', 'SimSun', 'SimHei', sans-serif;
            font-size: 14px;
            line-height: 1.6;
            color: #333;
            margin: 0;
            padding: 20px;
            background-color: white;
        }
        .title {
            font-size: 24px;
            font-weight: bold;
            text-align: center;
            margin-bottom: 30px;
            color: #2c3e50;
            border-bottom: 2px solid #3498db;
            padding-bottom: 10px;
        }
        h1, h2, h3, h4, h5, h6 {
            color: #2c3e50;
            margin-top: 1.5em;
            margin-bottom: 0.5em;
            font-weight: 600;
            line-height: 1.25;
        }
        h1 { font-size: 2em; }
        h2 { font-size: 1.5em; }
        h3 { font-size: 1.25em; }
        h4 { font-size: 1em; }
        h5 { font-size: 0.875em; }
        h6 { font-size: 0.85em; }
        p {
            margin: 0.8em 0;
            line-height: 1.8;
        }
        /* Ë°åÂÜÖ‰ª£Á†ÅÊ†∑Âºè */
        code {
            background-color: #f1f3f4;
            color: #d73a49;
            padding: 2px 6px;
            border-radius: 4px;
            font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Roboto Mono', 'Source Code Pro', 'Courier New', monospace;
            font-size: 0.85em;
            border: 1px solid #e1e4e8;
            white-space: nowrap;
        }
        
        /* ‰ª£Á†ÅÂùóÊ†∑Âºè */
        pre {
            background-color: #f6f8fa;
            border: 1px solid #e1e4e8;
            border-radius: 6px;
            padding: 16px;
            margin: 16px 0;
            overflow-x: auto;
            position: relative;
        }
        
        /* ‰ª£Á†ÅÂùóÂÜÖÁöÑ‰ª£Á†ÅÊ†∑Âºè */
        pre code {
            background-color: transparent;
            color: #24292e;
            padding: 0;
            border: none;
            border-radius: 0;
            font-size: 0.9em;
            line-height: 1.45;
            white-space: pre;
            word-wrap: normal;
            display: block;
        }
        
        /* ËØ≠Ê≥ïÈ´ò‰∫ÆÊ†∑Âºè */
        .hljs-keyword { color: #d73a49; }
        .hljs-string { color: #032f62; }
        .hljs-comment { color: #6a737d; font-style: italic; }
        .hljs-function { color: #6f42c1; }
        .hljs-number { color: #005cc5; }
        .hljs-operator { color: #d73a49; }
        .hljs-variable { color: #24292e; }
        blockquote {
            border-left: 4px solid #3498db;
            margin: 1.5em 0;
            padding: 16px 20px;
            color: #6a737d;
            background-color: #f6f8fa;
            border-radius: 0 8px 8px 0;
            font-style: italic;
            position: relative;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        blockquote::before {
            content: '"';
            font-size: 3em;
            color: #3498db;
            position: absolute;
            left: 10px;
            top: -10px;
            font-family: serif;
            opacity: 0.3;
            z-index: 0;
        }
        
        blockquote p {
            margin: 0.8em 0;
            line-height: 1.6;
            position: relative;
            z-index: 1;
            text-align: justify;
            white-space: pre-line; /* ‰øùÊåÅÊç¢Ë°å */
            min-height: 1.2em; /* Á°Æ‰øùÁ©∫ÊÆµËêΩÊúâÊúÄÂ∞èÈ´òÂ∫¶ */
        }
        
        blockquote p:first-child {
            margin-top: 0;
        }
        
        blockquote p:last-child {
            margin-bottom: 0;
        }
        
        /* Á©∫ÊÆµËêΩÊ†∑Âºè */
        blockquote p:empty,
        blockquote p:blank {
            min-height: 1.2em;
            margin: 0.4em 0;
        }
        
        blockquote br {
            display: block;
            content: "";
            margin: 0.3em 0;
        }
        
        blockquote strong {
            color: #24292f;
            font-weight: 600;
            font-style: normal;
        }
        
        blockquote code {
            background-color: #e1e4e8;
            color: #d73a49;
            font-style: normal;
            padding: 2px 4px;
            border-radius: 3px;
        }
        
        blockquote em {
            font-style: italic;
        }
        
        /* ÂºïÁî®ÂùóÂÜÖÁöÑÂàóË°®Ê†∑Âºè */
        blockquote ul, blockquote ol {
            margin: 0.5em 0;
            padding-left: 1.5em;
        }
        
        blockquote li {
            margin: 0.2em 0;
            line-height: 1.4;
        }
        
        blockquote ul {
            list-style-type: disc;
        }
        
        blockquote ol {
            list-style-type: decimal;
        }
        
        blockquote ul ul {
            list-style-type: circle;
        }
        
        blockquote ol ol {
            list-style-type: lower-alpha;
        }
        ul, ol {
            margin: 0.8em 0;
            padding-left: 2em;
        }
        
        ul ul, ol ol, ul ol, ol ul {
            margin: 0.5em 0;
            padding-left: 1.5em;
        }
        
        li {
            margin: 0.3em 0;
            line-height: 1.6;
        }
        
        li li {
            margin: 0.2em 0;
        }
        
        /* ÂàóË°®Ê†∑Âºè */
        ul {
            list-style-type: disc;
        }
        
        ul ul {
            list-style-type: circle;
        }
        
        ul ul ul {
            list-style-type: square;
        }
        
        ol {
            list-style-type: decimal;
        }
        
        ol ol {
            list-style-type: lower-alpha;
        }
        
        ol ol ol {
            list-style-type: lower-roman;
        }
        
        /* Ë°®Ê†ºÊ†∑Âºè */
        table {
            border-collapse: collapse;
            width: 100%;
            margin: 16px 0;
            font-size: 0.9em;
            border: 1px solid #d0d7de;
            border-radius: 6px;
            overflow: hidden;
        }
        
        thead {
            background-color: #f6f8fa;
        }
        
        tbody tr:nth-child(even) {
            background-color: #f6f8fa;
        }
        
        tbody tr:hover {
            background-color: #f0f0f0;
        }
        
        th, td {
            border: 1px solid #d0d7de;
            padding: 12px 16px;
            text-align: left;
            vertical-align: top;
            word-wrap: break-word;
        }
        
        th {
            font-weight: 600;
            color: #24292f;
            background-color: #f6f8fa;
        }
        
        /* ÂõæÁâáÊ†∑Âºè */
        img {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 16px auto;
            border-radius: 4px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        @page {
            size: A4;
            margin: 2cm;
        }
        
        /* Êï∞Â≠¶ÂÖ¨ÂºèÊ†∑Âºè */
        .math-inline {
            display: inline;
        }
        
        .math-block {
            text-align: center;
            margin: 1em 0;
            padding: 0.5em 0;
        }
        
        /* MathJax Ê†∑Âºè‰ºòÂåñ */
        .MathJax {
            font-size: 1em;
        }
        
        .MathJax_Display {
            margin: 1em 0;
        }
    </style>
</head>
<body>
    <div class="title">${title}</div>
    ${htmlContent}
</body>
</html>`;
    }

    markdownToHtml(markdown) {
        let html = markdown;
        
        // Á¨¨‰∏ÄÊ≠•ÔºöÂ§ÑÁêÜ‰ª£Á†ÅÂùóÔºàÂøÖÈ°ªÂú®ÊâÄÊúâÂÖ∂‰ªñÂ§ÑÁêÜ‰πãÂâçÔºâ
        html = this.processCodeBlocks(html);
        
        // Á¨¨‰∫åÊ≠•ÔºöÂ§ÑÁêÜÊ†áÈ¢ò
        html = html.replace(/^###### (.*$)/gim, '<h6>$1</h6>');
        html = html.replace(/^##### (.*$)/gim, '<h5>$1</h5>');
        html = html.replace(/^#### (.*$)/gim, '<h4>$1</h4>');
        html = html.replace(/^### (.*$)/gim, '<h3>$1</h3>');
        html = html.replace(/^## (.*$)/gim, '<h2>$1</h2>');
        html = html.replace(/^# (.*$)/gim, '<h1>$1</h1>');
        
        // Á¨¨‰∏âÊ≠•ÔºöÂ§ÑÁêÜË°åÂÜÖ‰ª£Á†Å
        html = html.replace(/`([^`]+)`/g, '<code>$1</code>');
        
        // Á¨¨ÂõõÊ≠•ÔºöÂ§ÑÁêÜÊï∞Â≠¶ÂÖ¨Âºè
        html = this.processMathFormulas(html);
        
        // Á¨¨‰∫îÊ≠•ÔºöÂ§ÑÁêÜÁ≤ó‰ΩìÂíåÊñú‰Ωì
        html = html.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
        html = html.replace(/\*(.*?)\*/g, '<em>$1</em>');
        
        // Á¨¨ÂÖ≠Ê≠•ÔºöÂ§ÑÁêÜÈìæÊé•ÂíåÂõæÁâá
        html = html.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2">$1</a>');
        html = html.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, '<img src="$2" alt="$1" style="max-width: 100%; height: auto;">');
        
        // Á¨¨‰∏ÉÊ≠•ÔºöÂ§ÑÁêÜÂàóË°®
        html = this.processLists(html);
        
        // Á¨¨ÂÖ´Ê≠•ÔºöÂ§ÑÁêÜÂºïÁî®Âùó
        html = this.processBlockquotes(html);
        
        // Á¨¨‰πùÊ≠•ÔºöÂ§ÑÁêÜÂàÜÂâ≤Á∫ø
        html = html.replace(/^---$/gim, '<hr>');
        
        // Á¨¨ÂçÅÊ≠•ÔºöÂ§ÑÁêÜË°®Ê†º
        html = this.processTables(html);
        
        // Á¨¨ÂçÅ‰∏ÄÊ≠•ÔºöÂ§ÑÁêÜÊÆµËêΩ
        html = this.processParagraphs(html);
        
        return html;
    }
    
    processCodeBlocks(html) {
        // ‰ΩøÁî®Âç†‰ΩçÁ¨¶‰øùÊä§‰ª£Á†ÅÂùóÂÜÖÂÆπ
        const codeBlocks = [];
        let blockIndex = 0;
        
        html = html.replace(/```(\w+)?\n([\s\S]*?)```/g, (match, lang, code) => {
            const language = lang || 'text';
            const placeholder = `__CODE_BLOCK_${blockIndex}__`;
            codeBlocks[blockIndex] = { language, code: code.trim() };
            blockIndex++;
            return placeholder;
        });
        
        // Â§ÑÁêÜÂÖ∂‰ªñÂÜÖÂÆπ...
        // ËøôÈáåÊöÇÊó∂ËøîÂõûÔºåÂêéÁª≠‰ºöÈáçÊñ∞ÊèíÂÖ•‰ª£Á†ÅÂùó
        
        // ÈáçÊñ∞ÊèíÂÖ•‰ª£Á†ÅÂùó
        codeBlocks.forEach((block, index) => {
            const placeholder = `__CODE_BLOCK_${index}__`;
            const codeHtml = `<pre><code class="language-${block.language}">${block.code}</code></pre>`;
            html = html.replace(placeholder, codeHtml);
        });
        
        return html;
    }
    
    processTables(html) {
        return html.replace(/(\|.*\|[\r\n]+)+/g, (match) => {
            const lines = match.trim().split('\n');
            if (lines.length < 2) return match;
            
            let tableHtml = '<table>\n';
            
            lines.forEach((line, index) => {
                const cells = line.split('|').filter(cell => cell.trim() !== '');
                if (cells.length === 0) return;
                
                if (index === 0) {
                    // Ë°®Â§¥
                    tableHtml += '<thead>\n<tr>\n';
                    cells.forEach(cell => {
                        tableHtml += `<th>${cell.trim()}</th>\n`;
                    });
                    tableHtml += '</tr>\n</thead>\n';
                } else if (index === 1) {
                    // ÂàÜÈöîË°åÔºåË∑≥Ëøá
                    return;
                } else {
                    // Êï∞ÊçÆË°å
                    if (index === 2) tableHtml += '<tbody>\n';
                    tableHtml += '<tr>\n';
                    cells.forEach(cell => {
                        tableHtml += `<td>${cell.trim()}</td>\n`;
                    });
                    tableHtml += '</tr>\n';
                }
            });
            
            tableHtml += '</tbody>\n</table>';
            return tableHtml;
        });
    }
    
    processParagraphs(html) {
        // Â§ÑÁêÜÊÆµËêΩ
        html = html.replace(/\n\n/g, '</p><p>');
        html = html.replace(/^(.+)$/gm, '<p>$1</p>');
        
        // Ê∏ÖÁêÜÂ§ö‰ΩôÁöÑÊÆµËêΩÊ†áÁ≠æ
        html = html.replace(/<p><\/p>/g, '');
        html = html.replace(/<p>(<h[1-6]>.*<\/h[1-6]>)<\/p>/g, '$1');
        html = html.replace(/<p>(<pre>.*<\/pre>)<\/p>/g, '$1');
        html = html.replace(/<p>(<blockquote>.*<\/blockquote>)<\/p>/g, '$1');
        html = html.replace(/<p>(<ul>.*<\/ul>)<\/p>/g, '$1');
        html = html.replace(/<p>(<ol>.*<\/ol>)<\/p>/g, '$1');
        html = html.replace(/<p>(<hr>)<\/p>/g, '$1');
        html = html.replace(/<p>(<table>.*<\/table>)<\/p>/g, '$1');
        html = html.replace(/<p>(<li>.*<\/li>)<\/p>/g, '$1');
        
        return html;
    }
    
    processLists(html) {
        // Â§ÑÁêÜÊó†Â∫èÂàóË°®
        html = this.processUnorderedLists(html);
        // Â§ÑÁêÜÊúâÂ∫èÂàóË°®
        html = this.processOrderedLists(html);
        return html;
    }
    
    processUnorderedLists(html) {
        const lines = html.split('\n');
        const result = [];
        let inList = false;
        let listItems = [];
        
        for (let i = 0; i < lines.length; i++) {
            const line = lines[i];
            const listMatch = line.match(/^(\s*)[*\-+] (.+)$/);
            
            if (listMatch) {
                const indent = listMatch[1].length;
                const content = listMatch[2];
                
                if (!inList) {
                    inList = true;
                    listItems = [];
                }
                
                listItems.push({ indent, content });
            } else {
                if (inList) {
                    result.push(this.buildNestedList(listItems, 'ul'));
                    listItems = [];
                    inList = false;
                }
                result.push(line);
            }
        }
        
        if (inList) {
            result.push(this.buildNestedList(listItems, 'ul'));
        }
        
        return result.join('\n');
    }
    
    processOrderedLists(html) {
        const lines = html.split('\n');
        const result = [];
        let inList = false;
        let listItems = [];
        
        for (let i = 0; i < lines.length; i++) {
            const line = lines[i];
            const listMatch = line.match(/^(\s*)\d+\. (.+)$/);
            
            if (listMatch) {
                const indent = listMatch[1].length;
                const content = listMatch[2];
                
                if (!inList) {
                    inList = true;
                    listItems = [];
                }
                
                listItems.push({ indent, content });
            } else {
                if (inList) {
                    result.push(this.buildNestedList(listItems, 'ol'));
                    listItems = [];
                    inList = false;
                }
                result.push(line);
            }
        }
        
        if (inList) {
            result.push(this.buildNestedList(listItems, 'ol'));
        }
        
        return result.join('\n');
    }
    
    buildNestedList(items, listType) {
        if (items.length === 0) return '';
        
        const result = [];
        let currentLevel = 0;
        let currentList = [];
        
        for (const item of items) {
            const level = Math.floor(item.indent / 2);
            
            if (level > currentLevel) {
                // ÂºÄÂßãÊñ∞ÁöÑÂµåÂ•óÂàóË°®
                currentList.push('<li>' + item.content);
                currentList.push(`<${listType}>`);
                currentLevel = level;
            } else if (level < currentLevel) {
                // ÁªìÊùüÂµåÂ•óÂàóË°®
                while (currentLevel > level) {
                    currentList.push(`</${listType}>`);
                    currentList.push('</li>');
                    currentLevel--;
                }
                currentList.push('<li>' + item.content + '</li>');
            } else {
                // ÂêåÁ∫ßÂàóË°®È°π
                currentList.push('<li>' + item.content + '</li>');
            }
        }
        
        // ÂÖ≥Èó≠ÊâÄÊúâÊú™ÂÖ≥Èó≠ÁöÑÂàóË°®
        while (currentLevel >= 0) {
            currentList.push(`</${listType}>`);
            if (currentLevel > 0) {
                currentList.push('</li>');
            }
            currentLevel--;
        }
        
        return `<${listType}>` + currentList.join('') + `</${listType}>`;
    }
    
    processBlockquotes(html) {
        const lines = html.split('\n');
        const result = [];
        let inBlockquote = false;
        let blockquoteLines = [];
        
        for (let i = 0; i < lines.length; i++) {
            const line = lines[i];
            
            // Ê£ÄÊü•ÊòØÂê¶ÊòØÂºïÁî®Ë°åÔºàÂåÖÊã¨Á©∫Ë°åÔºâ
            if (line.trim() === '' && inBlockquote) {
                // Á©∫Ë°åÔºåÁªßÁª≠ÂºïÁî®Âùó
                blockquoteLines.push('');
            } else if (line.trim().startsWith('>')) {
                if (!inBlockquote) {
                    inBlockquote = true;
                    blockquoteLines = [];
                }
                // ÁßªÈô§ÂºÄÂ§¥ÁöÑ ">" Âπ∂Ê∑ªÂä†Âà∞ÂºïÁî®Ë°åÊï∞ÁªÑ
                const content = line.replace(/^>\s*/, '');
                blockquoteLines.push(content);
            } else {
                // Â¶ÇÊûú‰∏çÊòØÂºïÁî®Ë°åÔºåÁªìÊùüÂΩìÂâçÁöÑÂºïÁî®Âùó
                if (inBlockquote) {
                    const blockquoteContent = this.processBlockquoteContent(blockquoteLines.join('\n'));
                    result.push(`<blockquote>${blockquoteContent}</blockquote>`);
                    blockquoteLines = [];
                    inBlockquote = false;
                }
                result.push(line);
            }
        }
        
        // Â§ÑÁêÜÊñá‰ª∂Êú´Â∞æÁöÑÂºïÁî®Âùó
        if (inBlockquote) {
            // ÂéªÊéâÁªìÂ∞æÁöÑÁ©∫Ë°å
            while (blockquoteLines.length > 0 && blockquoteLines[blockquoteLines.length - 1].trim() === '') {
                blockquoteLines.pop();
            }
            const blockquoteContent = this.processBlockquoteContent(blockquoteLines.join('\n'));
            result.push(`<blockquote>${blockquoteContent}</blockquote>`);
        }
        
        return result.join('\n');
    }
    
    processBlockquoteContent(content) {
        // Â§ÑÁêÜÂºïÁî®ÂùóÂÜÖÁöÑmarkdownËØ≠Ê≥ï
        let processedContent = content;
        
        // Â§ÑÁêÜË°åÂÜÖ‰ª£Á†ÅÔºàÂøÖÈ°ªÂú®Á≤ó‰ΩìÊñú‰Ωì‰πãÂâçÔºâ
        processedContent = processedContent.replace(/`([^`]+)`/g, '<code>$1</code>');
        
        // Â§ÑÁêÜÁ≤ó‰ΩìÂíåÊñú‰Ωì
        processedContent = processedContent.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
        processedContent = processedContent.replace(/\*(.*?)\*/g, '<em>$1</em>');
        
        // Â§ÑÁêÜÈìæÊé•
        processedContent = processedContent.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2">$1</a>');
        
        // Â§ÑÁêÜÂºïÁî®ÂùóÂÜÖÁöÑÂàóË°®
        processedContent = this.processBlockquoteLists(processedContent);
        
        // Â§ÑÁêÜÊÆµËêΩ - ‰øÆÂ§çÁâàÊú¨ÔºåÂåÖÂê´Á©∫Ë°å
        const lines = processedContent.split('\n');
        const paragraphs = [];
        let currentParagraph = [];
        
        for (const line of lines) {
            if (line.trim() === '') {
                // Á©∫Ë°åË°®Á§∫ÊÆµËêΩÂàÜÈöî
                if (currentParagraph.length > 0) {
                    paragraphs.push(currentParagraph.join('\n')); // ‰øùÊåÅÊç¢Ë°å
                    currentParagraph = [];
                }
                // Ê∑ªÂä†Á©∫ÊÆµËêΩÔºå‰øùÊåÅËÉåÊôØËâ≤
                paragraphs.push('');
            } else {
                // ÈùûÁ©∫Ë°åÊ∑ªÂä†Âà∞ÂΩìÂâçÊÆµËêΩ
                currentParagraph.push(line);
            }
        }
        
        // Â§ÑÁêÜÊúÄÂêé‰∏Ä‰∏™ÊÆµËêΩ
        if (currentParagraph.length > 0) {
            paragraphs.push(currentParagraph.join('\n')); // ‰øùÊåÅÊç¢Ë°å
        }
        
        // ÂéªÊéâÁªìÂ∞æÁöÑÁ©∫ÊÆµËêΩ
        while (paragraphs.length > 0 && paragraphs[paragraphs.length - 1] === '') {
            paragraphs.pop();
        }
        
        // ÂåÖË£ÖÊàêÊÆµËêΩÊ†áÁ≠æÔºå‰øùÊåÅÊç¢Ë°åÔºåÁ©∫ÊÆµËêΩ‰πüÂåÖË£Ö
        processedContent = paragraphs.map(p => {
            if (p === '') {
                return '<p>&nbsp;</p>'; // Á©∫ÊÆµËêΩ‰ΩøÁî®Á©∫Ê†º‰øùÊåÅËÉåÊôØËâ≤
            }
            return `<p>${p.replace(/\n/g, '<br>')}</p>`;
        }).join('');
        
        return processedContent;
    }
    
    processBlockquoteLists(content) {
        // Â§ÑÁêÜÂºïÁî®ÂùóÂÜÖÁöÑÊó†Â∫èÂàóË°®
        content = content.replace(/(^|\n)- (.+?)(?=\n(?!- )|$)/gms, (match, before, item) => {
            return `${before}<li>${item}</li>`;
        });
        
        // Â§ÑÁêÜÂºïÁî®ÂùóÂÜÖÁöÑÊúâÂ∫èÂàóË°®
        content = content.replace(/(^|\n)\d+\. (.+?)(?=\n(?!\d+\. )|$)/gms, (match, before, item) => {
            return `${before}<li>${item}</li>`;
        });
        
        // ÂåÖË£ÖÂàóË°®È°π
        content = content.replace(/(<li>.*<\/li>)/gs, '<ul>$1</ul>');
        
        return content;
    }
    
    processMathFormulas(html) {
        // Â§ÑÁêÜÂùóÁ∫ßÊï∞Â≠¶ÂÖ¨Âºè $$...$$ÔºàÂøÖÈ°ªÂú®Ë°åÂÜÖÂÖ¨Âºè‰πãÂâçÔºâ
        html = html.replace(/\$\$([\s\S]*?)\$\$/g, '<div class="math-block">\\[$1\\]</div>');
        
        // Â§ÑÁêÜË°åÂÜÖÊï∞Â≠¶ÂÖ¨Âºè $...$ÔºàÊéíÈô§Â∑≤ÁªèÂú®ÂùóÁ∫ßÂÖ¨Âºè‰∏≠ÁöÑÂÜÖÂÆπÔºâ
        html = html.replace(/(?<!\\\[)(?<!\\\()\$([^\$\n]+?)\$/g, '<span class="math-inline">\\($1\\)</span>');
        
        return html;
    }
    
    escapeHtml(text) {
        const map = {
            '&': '&amp;',
            '<': '&lt;',
            '>': '&gt;',
            '"': '&quot;',
            "'": '&#039;'
        };
        return text.replace(/[&<>"']/g, function(m) { return map[m]; });
    }

    async convertAll() {
        try {
            await this.init();

            if (this.action == "ÂçïÊñá‰ª∂ËΩ¨Êç¢") {
                const fileName = path.basename(this.mdFilePath, '.md');
                console.log(`üìñ Ê≠£Âú®ËΩ¨Êç¢: ${fileName}`);
                await this.convertMdToPdf(this.mdFilePath);
                return;
            }

            // Ëé∑ÂèñÊâÄÊúâmdÊñá‰ª∂
            const files = await fs.readdir(this.mdDir);
            const mdFiles = files.filter(file => file.toLowerCase().endsWith('.md'));
            
            if (mdFiles.length === 0) {
                console.log('üìÅ mdÁõÆÂΩï‰∏≠Ê≤°ÊúâÊâæÂà∞‰ªª‰Ωï.mdÊñá‰ª∂');
                return;
            }
            
            console.log(`üìö ÊâæÂà∞ ${mdFiles.length} ‰∏™mdÊñá‰ª∂ÔºåÂºÄÂßãËΩ¨Êç¢...`);
            
            // ÈÄê‰∏™ËΩ¨Êç¢Êñá‰ª∂
            for (let i = 0; i < mdFiles.length; i++) {
                console.log(`üìñ Ê≠£Âú®ËΩ¨Êç¢Á¨¨ ${i + 1}/${mdFiles.length} ‰∏™Êñá‰ª∂: ${mdFiles[i]}`);
                const file = mdFiles[i];
                const mdFilePath = path.join(this.mdDir, file);
                await this.convertMdToPdf(mdFilePath);
            }
            
            console.log('üéâ ÊâÄÊúâÊñá‰ª∂ËΩ¨Êç¢ÂÆåÊàêÔºÅ');
            
        } catch (error) {
            console.error('‚ùå ËΩ¨Êç¢ËøáÁ®ã‰∏≠ÂèëÁîüÈîôËØØ:', error);
        }
    }
}

const baseDir = process.cwd();
const getConfig = async () => {
  const actionType = await new inquirer([
    {
      type: "list",
      message: "ËØ∑ÈÄâÊã©Ë¶ÅËøõË°åÁöÑÊìç‰ΩúÔºö",
      name: "action",
      choices: ["ÂçïÊñá‰ª∂ËΩ¨Êç¢", "ÊâπÈáèËΩ¨Êç¢"],
    },
  ]).prompt();
  const options = [];
  if (actionType.action == "ÂçïÊñá‰ª∂ËΩ¨Êç¢") {
    options.push({
      type: "file",
      message: "ËØ∑ÈÄâÊã©ÈúÄË¶ÅËΩ¨Êç¢ÁöÑmarkdownÊñá‰ª∂Ôºö",
      name: "mdFilePath",
      dirname: baseDir,
      pathType: "absolute",
    })
  }else{
    options.push({
      type: "folder",
      message: "ËØ∑ÈÄâÊã©ÈúÄË¶ÅÊâπÈáèËΩ¨Êç¢ÁöÑÁõÆÂΩïÔºö",
      name: "mdDir",
      dirname: baseDir,
      pathType: "absolute",
    })
  }
  options.push({
    type: "folder",
    message: "ËØ∑ÈÄâÊã©ËæìÂá∫ÁöÑpdfÁõÆÂΩïÔºö",
    name: "pdfFilePath",
    dirname: baseDir,
    pathType: "absolute",
  })
  const answers = await new inquirer(options).prompt();
  return {
    ...actionType,
    ...answers
  }
}

const md2pdf = async () => {
  const res = await getConfig();
  console.log(res);
  const converter = new MarkdownToPdfConverter(res);
  await converter.convertAll();
}

module.exports = md2pdf;
